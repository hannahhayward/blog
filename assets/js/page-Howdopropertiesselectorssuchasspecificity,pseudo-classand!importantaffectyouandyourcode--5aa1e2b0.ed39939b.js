(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{466:function(e,t,s){"use strict";s.r(t);var o=s(2),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"how-do-properties-selectors-such-as-specificity-pseudo-class-and-important-affect-you-and-your-code"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-do-properties-selectors-such-as-specificity-pseudo-class-and-important-affect-you-and-your-code"}},[e._v("#")]),e._v(" How do properties/selectors such as specificity, pseudo-class and !important affect you and your code?")]),e._v(" "),s("blockquote",[s("p",[e._v("CSS properties/selectors such as specificity and pseudo-class are excellent tools that you can incorporate into your code to create accessibility ease. Specificity determines what rule must be executed if you have multiple rules targeting the same element. With the additional aid of selectors, you are able to override rules laid out in your code for each different scenario without having to individually write rules multiple times. When a selector is added to an element, it creates a greater specificity. The pseudo-class selector is a perfect example, as it indicates if your user performs this action, then your code must follow this rule. Itâ€™s a simple cause-and-effect event. Common examples include: :hover, :invalid, :first-child, and :last-child. Another way to override certain rules and specificity is by using the !important property. Although it is not commonly used in today's practices, circumstances may still arise when the property is needed. However, too many !important tags can create a mess of your code, and make it difficult to target the reason your code may not be behaving as intended.")])]),e._v(" "),s("p",[e._v("Lab Project: "),s("link"),e._v("https://github.com/hannahhayward/coolsite")])])}),[],!1,null,null,null);t.default=a.exports}}]);